## 哈希冲突(哈希碰撞)
```
概念: 两个不同的key, 经过哈希函数计算出相同的结果

解决哈希冲突的常见方法:

开放定址法: 当出现了哈希冲突时, 即当前哈希值对应的数组索引下存在元素的时候, 这时采用一定的规则向其
           它地址探测, 直到遇到空桶为止, 这个规则可以是线性探测, 即往下一个个去访问, 也可以是平方
           探测, 每次跳跃1-n的平方个索引进行判断是否存在空桶

再哈希法: 设计多个哈希函数, 当第一个哈希函数计算出的索引下已经存在值的时候, 继续用另一个哈希函数进行
          计算索引, 直到遇到空桶为止

链地址法: 通过链表将同一个索引的元素串起来, 比如字符串a和字符串b算出来的哈希值相同, 此时将它们的值
          均存放在该索引下, 但是通过链表将它们的值串起来

JDK1.8的哈希冲突解决方案(链表+红黑树):
  <1> 默认使用单向链表将元素串起来
  <2> 当整个哈希表中总的元素的个数大于64个并且单向链表中有一个链表的节点个数大于8个的时候, 将会把
      单向链表转换为红黑树来存储元素
  <3> 当红黑树中节点数量少到一定程度的时候, 又会将红黑树转换为单向链表

为什么要使用单向链表? 首先是使用链表, 我们插入一个值的时候, 如果该key对应的索引下已经存在值了, 即
已经存在一个链表了, 那么我们这个新添加的值是需要往链表的尾部去添加的, 而不是头部, 因为我们在添加的
过程中, 还需要判断是否当前key已经存在于该链表了, 如果存在, 则直接覆盖, 不存在则在尾部添加, 所以是
要对链表进行遍历一遍的, 其次单链表相对于双链表来说, 少了一个指针的维护, 节省了空间, 由于我们只需要
从头遍历到尾, 所以单链表是最合适的
```

## 哈希函数的描述
```
实现步骤:
  <1> 首先利用hashCode方法生成key对应的哈希值(必须是一个整数)
  <2> 让key的哈希值跟数组的大小进行相关运算, 生成该哈希值对应在数组的索引值

关于这个相关运算, 可以有如下两种方式:
  方式一(对数组的大小进行取模运算):
    private int hash (Object key) {
      return hashCode(key) % table.length;
    }
  方式二(为了提高效率, 可以使用&运算来替代取模运算[前提是数组的长度必须是2的幂]):
    private int hash (Object key) {
      return hashCode(key) & (table.length - 1);
    }

为什么使用取模运算?
  因为我们计算出的哈希值可能是大于数组的长度的, 而索引是小于数组的长度的, 通过取模运算, 无论哈希值
  多大都能转换成数组长度内的值

为什么&运算中数组长度必须是2的幂?
  10      2^1
  100     2^2
  1000    2^3
  10000   2^4
  100000  2^5

  1       2^1 - 1
  11      2^2 - 1
  111     2^3 - 1
  1111    2^4 - 1
  11111   2^5 - 1

当table.length为2^n时, 则table.length - 1一定是一个全11111的值, 根据&运算的规则, 两者都为1的情况
下才得1, 其它情况均为0, 所以不管一个数多么的大, 则其转换为二进制数后只能留下tabke.length-1的值,
举个例子:
  1011001110010101
& 0000000000011111(2 ^ 5 - 1)
-----------------------------
  0000000000010101

结论: 通过对一个2^n - 1的值进行&运算, 会使得结果一定小于等于该值, 也就达到了使得一个哈希值在数组长
      度的范围了, 一个良好的哈希函数应该使得哈希值生成索引后分布在数组时更加均匀, 从而能减少哈希冲
      突, 进而提升哈希表的性能
```

## 如何生成一个key为int和float的哈希值
```
整数: 哈希值是一个整数, 所以如果一个key为整数, 则该整数本身就可以成为一个哈希值

浮点数: 由于哈希值需要是一个整数, 对于浮点数来说, 其在内存中同样是以二进制的形式存储的, 所以我们只
        需要将该二进制拿出来, 算出其对应的整数, 则该整数就可以成为该浮点数的哈希值了
        利用Float中自带的静态方法int Float.floatToIntBits(float value)可以获取到该整数, 然后该
        整数就可以成为哈希值了

由于float是4个字节, 整数是同样的4个字节, 所以可以直接利用float在内存中存储的形式来转换为整型, 然后
当做其哈希值
```

## 如何生成一个key为long和double的哈希值
```
long:
  private static int hashCode (long value) {
    return (int) ( value ^ ( value >>> 32 ) );
  }

double:
  private static int hashCode (double value) {
    long bits = doubleToLongBits(value);
    return (int) ( bits ^ ( bits >>> 32 ) );
  }

long和double: long和double都是8个字节64位, 对应hash值来说, 必须是整数, 所以需要将long和double转
              换成整数, 对于doubleToLongBits方法来说, 由于double在内存中也是二进制存储, 所以只
              需要将这个二进制(64位)转换成long类型, 然后利用long类型的方式计算哈希值即可

^与运算和>>>无符号右移运算:
  这两个运算的作用是利用高32位和低32位混合计算出一个32位的哈希值, 之所以这样是我们需要充分利用所有
  信息来计算哈希值, 即要把所有的数都用上, 而不是仅仅只用一部分, 这样可以减少冲突, 举个例子, 字符串
  jack和字符串back, 如果我们仅仅只用ck即最后两位进行运算的话, 很容易就出现哈希冲突了, 所以需要利用
  所有的值进行哈希值的计算

>>>无符号右移运算:
  该运算的结果就是为了使得低32位的值变为高32位的值, 举个例子:
  1111 1111 1111 1111 0101 1010 0010 1001
  >>> 32(执行无符号右移32位)
  0000 0000 0000 0000 1111 1111 1111 1111
  可以看到, 低32位的值已经变成了高32位的值了, 所以>>>无符号右移运算的作用就是使得低32位的值变为高
  32位的值

^异或运算:
  举个例子, 使用右移运算得出的结果与原来的结果进行异或运算:
  0000 0000 0000 0000 1111 1111 1111 1111
  ^(异或原来的值)
  1111 1111 1111 1111 0101 1010 0010 1001
  ---------------------------------------
  1111 1111 1111 1111 1010 0101 1101 0110

根据源代码可以看到, 还进行了强转int, 所以结果就只剩下了低32位的值了, 也就是说其实最终的结果就是高
32位的值和低32位的值进行了异或运算而已, 这样就充分利用了所有的数据, 那么为什么使用异或而不使用与&
运算或者|或运算呢?因为&运算当我们的值全为1的时候, 如下:
  0101 1010 0010 1001       0101 1010 0010 1001
& 1111 1111 1111 1111     | 1111 1111 1111 1111
  --------------------      --------------------
  0101 1010 0010 1001       1111 1111 1111 1111

可以发现, 当出现了一个全为1的值的时候, 运算后的结果就是上面的值, 其实就等于直接取上面的值了, 而没有
对所有的值进行运算了, 或运算也是如此, 当出现了一个全为1的值的时候, 运算后的结果就是全为1的那个值,
也等于没有对所有值进行运算了, 而仅仅只有异或运算, 才能使得所有的值参与进来, 得到一个不同于原来运算
值的结果, 所以这两个运算的作用是利用高32位和低32位混合计算出一个32位的哈希值
```

## 如何生成一个key为字符串的哈希值
```
对于一个整数来说, 其哈希值就等于其本身, 例如5174的哈希值就是5174, 但是5174可以如下表示:
5174 = 5 * 10^3 + 1 * 10^2 + 7 * 10^1 + 4 * 10^0
对于字符串来说, 底层是一个char字符数组, 而字符是可以用ASCII码表示的, 所以一个字符串jack可以如下表示:
hashCode(jack) = j * n^3 + a * n^2 + c * n^1 + k * n^0

至于这个n取多少呢? 在JDK的String源码中取的是31, 因为31是一个奇素数, 利用素数计算的出的哈希值更不
容易重复, 从而可以减少哈希冲突, 并且i * 31在JVM中会被优化成(i << 5 - 1), 二进制运算相对于正常的乘
除运算肯定是更加的快的

所以得出结论, 一个字符串的哈希值计算如jack即为:
  hashCode(jack) = j * n^3 + a * n^2 + c * n^1 + k * n^0

对于上面的这个运算来说, 还可以进行优化, 那就是对于n^2来说, 其已经在j * n^3中进行了一次计算了, 我们
可以将上述运算等价于( ( j * n + a ) * n + c ) * n + k, 即:
  hashCode(jack) = j * n^3 + a * n^2 + c * n^1 + k * n^0
                 = ( ( j * n + a ) * n + c ) * n + k

即JDK中String的源码hashCode就是这样计算的:
  public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
  }
```

## 如何生成一个key为自定义对象的哈希值
```
Person类:
  class Person {
    private String name;
    private int age;
    private float height;
  }

Person类的hashCode方法可以仿照String的方式:
  public int hashCode () {
    int hash = name == null ? 0 : name.hashCode;
    hash = hash * 31 + Integer.hashCode(age);
    hash = hash * 31 + Float.hashCode(height);

    return hash;
  }
```

## equals方法的实现
```
Person类:
  class Person {
    private String name;
    private int age;
    private float height;
  }

首先我们需要知道equals在什么时候起作用, 在HashMap中, 我们增加一个键值对, 首先会对该键值对生成一个
哈希值, 然后利用该哈希值进行索引位置的计算(与运算或者取模运算), 得出该键值对应该存放在HashMap的哪个
索引下, 如果该索引下存在元素, 那么就利用equals方法对这些元素和新增的元素进行判断, 如果相等, 则将新
增元素的值替换原来的值, 如果在链表中一直比较到最后都没有出现相等的情况, 则将该元素添加到该链表的末尾

假设Person类中当name, age, height都相等的情况下才是相等的, 则equals实现为:
  public boolean equals (Object obj) {
    if ( obj == this ) return true; // 如果两个对象内存地址都一样了, 那就一定相等了
    // 如果obj是空的, 但是当前对象一定不是空, 自然两者就不相等了
    // 如果obj和当前对象都不是同一个类对象, 那自然也就不相等了
    if ( obj == null || this.getClass() != obj.getClass() ) return false;

  Person per = (Person) obj;

  // 对name需要判空, 否则可能会空指针异常
  return   age == per.age
        && height == per.height
        && name == null ? per == null : name.equals( per.name );
  }
```
