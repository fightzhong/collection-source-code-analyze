## m阶BTree的性质(m >= 2)
```
<1> 一个节点可以存储超过两个元素, 可以拥有超过两个子节点
<2> 拥有二叉搜索树的性质
<3> 每个节点的所有子树高度都一致
<4> 比较矮

对于一个m阶BTree, 假设一个Node存储的元素个数为x, x满足以下性质:
  如果该节点是根节点, 则 1 <= x <= m - 1
  如果该节点不是根节点, 则ceil(m / 2) - 1 <= x <= m - 1
  如果该节点存在子节点, 那么其子节点的个数y一定为y = x + 1
  举个例子:
    如果是4阶BTree, 那么根节点存储的元素个数范围是(1, 3), 非根节点存储的元素个数范围是(1,3)
    如果是6阶BTree, 那么根节点存储的元素个数范围是(1, 5), 非根节点存储的元素个数范围是(2,5)
    如果m阶BTree根节点存储的元素个数为3个, 那么如果存在子节点, 则其子节点的个数一定为4个

综上的结论, 我们可以得到一个节点如果存在子节点, 则子节点的个数y有以下规律:
如果该节点是根节点, 则其子节点个数y = x + 1, 即 2 <= y <= m
如果该节点不是根节点, 则其子节点个数y = x + 1, 即 ceil(m / 2) <= y <= m

如果m = 3, 即三阶BTree, 那么其子节点的个数y的范围为 2 <= y <= 3, 即子节点的个数, 也叫2-3树
如果m = 4, 即四阶BTree, 那么其子节点的个数y的范围为 2 <= y <= 3, 即子节点的个数, 也叫2-3-4树

为什么一个节点不是根节点, 则其存储的的元素个数为范围ceil(m / 2) - 1 <= x <= m - 1呢, 我们假设现在
是一个五阶BTree, 那么其根节点中可以存放的元素个数范围是1-4个, 假设根节点已经有4个节点了, 那么当我们
再添加一个节点后, 如: 根节点(20, 30, 40, 50), 添加一个60, 则变成根节点(20, 30, 40, 50, 60), 为了
维护根节点的范围, 我们需要进行分离, 则从40分成两份, 即40作为根节点, (20, 30)作为左节点, (50, 60)
作为右节点, 即我们可以看到通过此次分离后, 子节点最少都是2个, 同样的道理, 当我们为七阶BTree时, 当
元素增加到7个时, 为了维护最多6个元素, 则从中间那个进行分离, 从而变成了左右节点均为3个元素, 即子节点
的个数至少都是3个的
```
## BTree的搜索
```
- 先在当前节点进行查找, 如果命中则返回
- 如果没有命中, 则进行比较, 去对应的子节点中进行查找, 并重复步骤一
```

## BTree的增加及上溢
```
BTree的节点增加一定发生在叶子节点的情况下, 我们假设添加了一个元素后该元素添加的位置对应的节点的元素
个数超过了当前BTree的限制, 比如4阶BTree不能超过3个元素, 那么就导致了BTree的上溢, 那么如果解决这个
上溢呢?
<1> 上溢的节点的个数一定为m个(m为阶的意思, 表示m阶BTree), 因为m阶BTree的最多元素个数为m - 1个
<2> 假设我们的是4阶BTree, 并且上溢的节点的最中间元素的位置为k, 如(20, 30, 40, 50)最中间元素的位置
    为30, 则将k位置的元素做为一个根节点, 并将[0, k - 1]以及[k + 1, m - 1]位置的元素分成两份, 分别
    作为k元素的左右子节点, 然后将k节点向上与父节点合并
<3> 一次分裂完成后, 有可能也会导致父节点上溢, 依然按照上述方法解决

下面我们用图来进行演示
```
- 四阶BTree

<img src="photos\BTree\四阶BTree1.png" >

- 增加99导致上溢的发生

<img src="photos\BTree\四阶BTree2.png" >

- 解决叶子节点上溢, 通过分裂, 将97作为根节点后, 其它元素作为其左右节点, 97向上合并

<img src="photos\BTree\四阶BTree3.png" >

- 增加100, 不会导致上溢

<img src="photos\BTree\四阶BTree4.png" >

- 增加101导致上溢

<img src="photos\BTree\四阶BTree5.png" >

- 解决叶子节点上溢, 通过分裂, 将99作为根节点后, 其它元素作为其左右节点, 99向上合并

<img src="photos\BTree\四阶BTree6.png" >

- 解决99合并后导致合并后的节点上溢, 通过分裂, 将90作为根节点, 其它元素作为其左右节点, 90向上合并

<img src="photos\BTree\四阶BTree7.png" >

## BTree的删除及下溢
```
如果删除一个叶子节点, 那么就是BTree的正常删除逻辑, 如果删除的是一个非叶子节点的元素A, 那么就需要找到
该元素的前驱(其子节点中左孩子中最大的那个元素)或者后继(其子节点中右孩子中最小的那个元素), 然后将该
元素替换到元素A中, 所以最终还是删除的是叶子节点, 那么如果删除叶子节点后继续保持平衡呢?

那么删除一个叶子节点的元素后可能会出现一种情况, 那就是删除该叶子节点的元素个数没有达到当前BTree的
元素个数范围了, 比如5阶BTree中非根节点的元素的个数范围是[2, 4], 假设我们删除了一个有两个元素的叶子
节点中的一个元素后, 导致了该节点没达到范围, 该情况就交下溢, 那么如何解决下溢呢?

<1> 非根节点的m阶BTree的元素个数范围是[ceil(m / 2) - 1, m - 1]
<2> 下溢节点的元素个数必然等于ceil(m / 2) - 2
<3> 如果下溢节点临近的兄弟节点, 有至少ceil(m / 2)个元素, 即比左边界的元素个数多了一个, 那么就可以
    向该兄弟节点借一个
<4> 即将父节点的元素b插入到下溢节点的最左边, 将兄弟节点中最大的那个元素a替代父节点元素b的位置
<5> 这种操作就是旋转, 如下图1所示

<6> 如果下溢节点临近的兄弟节点, 只有ceil(m / 2) - 1个元素
<7> 将父节点的元素b挪下来跟左右节点进行合并
<8> 合并后的节点个数一定不超过m - 1, 因为临近兄弟节点的元素个数为ceil(m / 2) - 1, 下溢的节点元素
    个数为ceil(m / 2) - 2, 将父节点挪下来后加了一个元素, 则是
    ceil(m / 2) - 1 + 1 + ceil(m / 2) - 2 = ceil(m / 2) + ceil(m / 2) - 2
    一定是小于等于m - 1的, 如下图2
```

<img src="photos\BTree\BTree删除之下溢1.png" >

<img src="photos\BTree\BTree删除之下溢2.png" >

